
#[test]
fn test_collapse() {
    use crate::common::{Halfedge, Tref};
    use nalgebra::{RowVector3 as Row3};
    use super::collapse_collinear_edges;

    let mut hs = vec![
        Halfedge::new(0, 4, 5),
        Halfedge::new(4, 1, 42),
        Halfedge::new(1, 0, 9),
        Halfedge::new(0, 2, 26),
        Halfedge::new(2, 4, 50),
        Halfedge::new(4, 0, 0),
        Halfedge::new(0, 11, 11),
        Halfedge::new(11, 9, 57),
        Halfedge::new(9, 0, 21),
        Halfedge::new(0, 1, 2),
        Halfedge::new(1, 11, 14),
        Halfedge::new(11, 0, 6),
        Halfedge::new(1, 10, 17),
        Halfedge::new(10, 11, 68),
        Halfedge::new(11, 1, 10),
        Halfedge::new(1, 3, 35),
        Halfedge::new(3, 10, 20),
        Halfedge::new(10, 1, 12),
        Halfedge::new(3, 13, 31),
        Halfedge::new(13, 10, 66),
        Halfedge::new(10, 3, 16),
        Halfedge::new(0, 9, 8),
        Halfedge::new(9, 12, 59),
        Halfedge::new(12, 0, 24),
        Halfedge::new(0, 12, 23),
        Halfedge::new(12, 2, 27),
        Halfedge::new(2, 0, 3),
        Halfedge::new(2, 12, 25),
        Halfedge::new(12, 13, 64),
        Halfedge::new(13, 2, 30),
        Halfedge::new(2, 13, 29),
        Halfedge::new(13, 3, 18),
        Halfedge::new(3, 2, 36),
        Halfedge::new(1, 7, 47),
        Halfedge::new(7, 3, 37),
        Halfedge::new(3, 1, 15),
        Halfedge::new(2, 3, 32),
        Halfedge::new(3, 7, 34),
        Halfedge::new(7, 2, 51),
        Halfedge::new(4, 6, 49),
        Halfedge::new(6, 5, 54),
        Halfedge::new(5, 4, 43),
        Halfedge::new(1, 4, 1),
        Halfedge::new(4, 5, 41),
        Halfedge::new(5, 1, 45),
        Halfedge::new(1, 5, 44),
        Halfedge::new(5, 7, 56),
        Halfedge::new(7, 1, 33),
        Halfedge::new(2, 6, 53),
        Halfedge::new(6, 4, 39),
        Halfedge::new(4, 2, 4),
        Halfedge::new(2, 7, 38),
        Halfedge::new(7, 6, 55),
        Halfedge::new(6, 2, 48),
        Halfedge::new(5, 6, 40),
        Halfedge::new(6, 7, 52),
        Halfedge::new(7, 5, 46),
        Halfedge::new(9, 11, 7),
        Halfedge::new(11, 12, 61),
        Halfedge::new(12, 9, 22),
        Halfedge::new(8, 12, 65),
        Halfedge::new(12, 11, 58),
        Halfedge::new(11, 8, 69),
        Halfedge::new(8, 13, 71),
        Halfedge::new(13, 12, 28),
        Halfedge::new(12, 8, 60),
        Halfedge::new(10, 13, 19),
        Halfedge::new(13, 11, 70),
        Halfedge::new(11, 10, 13),
        Halfedge::new(8, 11, 62),
        Halfedge::new(11, 13, 67),
        Halfedge::new(13, 8, 63),
    ];

    let mut ps = vec![
        Row3::new(-0.8, -1., -1.),
        Row3::new(-0.8, -1., 1.),
        Row3::new(-0.8, 1., -1.),
        Row3::new(-0.8, 1., 1.),
        Row3::new(1.2, -1., -1.),
        Row3::new(1.2, -1., 1.),
        Row3::new(1.2, 1., -1.),
        Row3::new(1.2, 1., 1.),
        Row3::new(0., 0., 0.),
        Row3::new(-0.8, -0.14641, -0.14641),
        Row3::new(-0.8, 0.2, 0.2),
        Row3::new(-0.8, -0.34641, 0.2),
        Row3::new(-0.8, 0., -0.4),
        Row3::new(-0.8, 0.34641, 0.2),
    ];

    let mut ns = vec![
        Row3::new(-0., -1., -0.),
        Row3::new(-0., -0., -1.),
        Row3::new(-1., -0., 0.),
        Row3::new(-1., -0., 0.),
        Row3::new(-1., -0., 0.),
        Row3::new(-1., -0., 0.),
        Row3::new(-1., -0., -0.),
        Row3::new(-1., -0., -0.),
        Row3::new(-1., -0., -0.),
        Row3::new(-1., -0., -0.),
        Row3::new(-1., -0., -0.),
        Row3::new(0., 0., 1.),
        Row3::new(0., 1., 0.),
        Row3::new(1., 0., 0.),
        Row3::new(0., -1., 0.),
        Row3::new(-0., 0., 1.),
        Row3::new(0., 0., -1.),
        Row3::new(-0., 1., 0.),
        Row3::new(1., 0., -0.),
        Row3::new(-0.242536, 0.840168, 0.485071),
        Row3::new(-0.242536, 0.840168, 0.485071),
        Row3::new(-0.242536, -0.840168, 0.485071),
        Row3::new(-0.242536, -3.22877e-20, -0.970143),
        Row3::new(-0.242536, -3.22877e-20, -0.970143),
    ];

    let mut refs = vec![
        Tref{mesh_id: 1, face_id: 0, origin_id: -2, planar_id: 3},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 5},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 1},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 0},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 4},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 3},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 1},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 5},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 0},
        Tref{mesh_id: 1, face_id: 0, origin_id: -1, planar_id: 4},
        Tref{mesh_id: 2, face_id: 0, origin_id: -1, planar_id: 0},
        Tref{mesh_id: 2, face_id: 0, origin_id: -1, planar_id: 0},
        Tref{mesh_id: 2, face_id: 0, origin_id: -1, planar_id: 3},
        Tref{mesh_id: 2, face_id: 0, origin_id: -1, planar_id: 2},
        Tref{mesh_id: 2, face_id: 0, origin_id: -1, planar_id: 2},
    ];

    collapse_collinear_edges(
        &mut hs,
        &mut ps,
        &mut ns,
        &mut refs,
        9,
        1e-6
    );

    let hs_out = vec![
        (0, 4, 5),
        (4, 1, 42),
        (1, 0, 9),
        (0, 2, 26),
        (2, 4, 50),
        (4, 0, 0),
        (0, 11, 11),
        (11, 12, 61),
        (12, 0, 24),
        (0, 1, 2),
        (1, 11, 17),
        (11, 0, 6),
        (-1, -1, -1),
        (-1, -1, -1),
        (-1, -1, -1),
        (1, 3, 35),
        (3, 11, 20),
        (11, 1, 10),
        (3, 13, 31),
        (13, 11, 70),
        (11, 3, 16),
        (-1, -1, -1),
        (-1, -1, -1),
        (-1, -1, -1),
        (0, 12, 8),
        (12, 2, 27),
        (2, 0, 3),
        (2, 12, 25),
        (12, 13, 64),
        (13, 2, 30),
        (2, 13, 29),
        (13, 3, 18),
        (3, 2, 36),
        (1, 7, 47),
        (7, 3, 37),
        (3, 1, 15),
        (2, 3, 32),
        (3, 7, 34),
        (7, 2, 51),
        (4, 6, 49),
        (6, 5, 54),
        (5, 4, 43),
        (1, 4, 1),
        (4, 5, 41),
        (5, 1, 45),
        (1, 5, 44),
        (5, 7, 56),
        (7, 1, 33),
        (2, 6, 53),
        (6, 4, 39),
        (4, 2, 4),
        (2, 7, 38),
        (7, 6, 55),
        (6, 2, 48),
        (5, 6, 40),
        (6, 7, 52),
        (7, 5, 46),
        (-1, -1, -1),
        (-1, -1, -1),
        (-1, -1, -1),
        (8, 12, 65),
        (12, 11, 7),
        (11, 8, 69),
        (8, 13, 71),
        (13, 12, 28),
        (12, 8, 60),
        (-1, -1, -1),
        (-1, -1, -1),
        (-1, -1, -1),
        (8, 11, 62),
        (11, 13, 19),
        (13, 8, 63),
    ];

    let ps_out = vec![
        Row3::new(-0.8, -1., -1.),
        Row3::new(-0.8, -1., 1.),
        Row3::new(-0.8, 1., -1.),
        Row3::new(-0.8, 1., 1.),
        Row3::new(1.2, -1., -1.),
        Row3::new(1.2, -1., 1.),
        Row3::new(1.2, 1., -1.),
        Row3::new(1.2, 1., 1.),
        Row3::new(0., 0., 0.),
        Row3::new(f64::MAX, f64::MAX, f64::MAX),
        Row3::new(f64::MAX, f64::MAX, f64::MAX),
        Row3::new(-0.8, -0.34641, 0.2),
        Row3::new(-0.8, 0., -0.4),
        Row3::new(-0.8, 0.34641, 0.2),
    ];

    for i in 0..hs.len() {
        let h = &hs[i];
        let a = hs[i].tail;
        let b = hs[i].head;
        let c = hs[i].pair;
        let (d, e, f) = hs_out[i];
        if h.no_tail() { assert_eq!(d, -1); } else { assert_eq!(a as i32, d); }
        if h.no_head() { assert_eq!(e, -1); } else { assert_eq!(b as i32, e); }
        if h.no_pair() { assert_eq!(f, -1); } else { assert_eq!(c as i32, f); }
    }

    for i in 0..ps.len() {
        let p0 = &ps[i];
        let p1 = &ps_out[i];
        if p0.x == f64::MAX && p0.y == f64::MAX && p0.z == f64::MAX { assert_eq!(p1.x, f64::MAX); }
        else { assert!((p0 - p1).norm() < 1e-6); }
    }
}
